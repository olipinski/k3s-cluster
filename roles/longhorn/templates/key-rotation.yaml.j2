apiVersion: batch/v1
kind: CronJob
metadata:
  name: longhorn-encryption-key-rotation
  namespace: {{ longhorn_vars.kubernetes.namespace }}
spec:
  schedule: "0 0 1 */3 *"  # Run every 3 months
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 3
      template:
        spec:
          serviceAccountName: longhorn-service-account
          securityContext:
            runAsUser: 0
          containers:
          - name: key-rotation
            image: bitnami/kubectl:latest
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop: ["ALL"]
            command:
            - /bin/bash
            - -c
            - |
              #!/bin/bash
              set -e

              echo "Starting encryption key rotation at $(date)"

              # Generate new key with higher entropy
              NEW_KEY=$(head -c 64 /dev/urandom | base64 | tr -d '\n')

              # Store new key in temporary secret with managed metadata
              echo "Creating new encryption key secret"
              kubectl create secret generic {{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}-new \
                --namespace {{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_namespace }} \
                --from-literal=CRYPTO_KEY_VALUE="$NEW_KEY" \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Created new encryption key"

              # Phase 1: Rotate non-critical volumes first
              echo "Phase 1: Rotating non-critical volumes first"
              # Get volumes excluding system namespaces
              NON_CRITICAL_VOLUMES=$(kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io \
                -o jsonpath='{range .items[*]}{.metadata.name}{","}{.status.kubernetesStatus.namespace}{","}{.status.state}{"\n"}{end}' | \
                grep -v ",kube-system," | grep -v ",longhorn-system," | grep -v ",cattle-system,")

              # Process small batches of 5 volumes at a time
              BATCH_SIZE=5
              ROTATED_COUNT=0

              # Process volumes in small batches
              echo "$NON_CRITICAL_VOLUMES" | while IFS=, read -r VOLUME NAMESPACE STATE; do
                if [ -z "$VOLUME" ]; then continue; fi

                if kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME -o jsonpath='{.spec.encrypted}' | grep -q "true"; then
                  echo "Rotating key for volume: $VOLUME (namespace: $NAMESPACE, state: $STATE)"

                  kubectl patch -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME --type=json \
                    -p='[{"op": "replace", "path": "/spec/keySecret", "value": "{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}-new@{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_namespace }}"}]'

                  ROTATED_COUNT=$((ROTATED_COUNT+1))

                  # If we've rotated a batch, wait before continuing
                  if [ $((ROTATED_COUNT % BATCH_SIZE)) -eq 0 ]; then
                    echo "Rotated $ROTATED_COUNT volumes. Waiting for 5 minutes before continuing..."
                    sleep 300
                  else
                    sleep 10
                  fi
                fi
              done

              # Only continue to system volumes if non-critical volumes rotated successfully
              if [ $ROTATED_COUNT -gt 0 ]; then
                echo "Successfully rotated $ROTATED_COUNT non-critical volumes"
                echo "Waiting for stabilization before proceeding to system volumes (15 minutes)..."
                sleep 900

                # Phase 2: Now rotate system volumes with extra caution (one at a time)
                echo "Phase 2: Rotating system volumes one at a time"
                SYSTEM_VOLUMES=$(kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io \
                  -o jsonpath='{range .items[*]}{.metadata.name}{","}{.status.kubernetesStatus.namespace}{","}{.status.state}{"\n"}{end}' | \
                  grep -E ",(kube-system|longhorn-system|cattle-system),")

                SYSTEM_ROTATED=0

                echo "$SYSTEM_VOLUMES" | while IFS=, read -r VOLUME NAMESPACE STATE; do
                  if [ -z "$VOLUME" ]; then continue; fi

                  if kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME -o jsonpath='{.spec.encrypted}' | grep -q "true"; then
                    echo "Rotating key for SYSTEM volume: $VOLUME (namespace: $NAMESPACE, state: $STATE)"

                    # Extra verification before rotation
                    VOLUME_ROBUSTNESS=$(kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME -o jsonpath='{.status.robustness}')
                    if [[ "$VOLUME_ROBUSTNESS" != "healthy" ]]; then
                      echo "WARNING: System volume $VOLUME is not healthy (robustness: $VOLUME_ROBUSTNESS). Skipping."
                      continue
                    fi

                    kubectl patch -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME --type=json \
                      -p='[{"op": "replace", "path": "/spec/keySecret", "value": "{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}-new@{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_namespace }}"}]'

                    SYSTEM_ROTATED=$((SYSTEM_ROTATED+1))

                    # Wait longer for system volumes
                    echo "Waiting for system volume to stabilize (2 minutes)..."
                    sleep 120

                    # Verify again after rotation
                    VOLUME_ROBUSTNESS=$(kubectl get -n {{ longhorn_vars.kubernetes.namespace }} volumes.longhorn.io $VOLUME -o jsonpath='{.status.robustness}')
                    if [[ "$VOLUME_ROBUSTNESS" != "healthy" ]]; then
                      echo "ERROR: System volume $VOLUME is not healthy after rotation! Aborting."
                      exit 1
                    fi
                  fi
                done

                # Only update the main key if some volumes were rotated successfully
                if [ $ROTATED_COUNT -gt 0 ] || [ $SYSTEM_ROTATED -gt 0 ]; then
                  echo "Successfully rotated keys for $ROTATED_COUNT non-critical and $SYSTEM_ROTATED system volumes"
                  echo "Updating main key secret..."

                  kubectl get secret {{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}-new \
                    -n {{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_namespace }} -o yaml | \
                    sed "s/{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}-new/{{ longhorn_vars.kubernetes.default_settings.csi_encryption_kms_secret_name }}/" | \
                    kubectl replace -f - --force

                  echo "Key rotation completed successfully at $(date)"
                else
                  echo "No volumes were rotated. Keeping old key active."
                fi
              else
                echo "No volumes were rotated successfully. Aborting key update."
                exit 1
              fi
            volumeMounts:
            - name: tmp
              mountPath: /tmp
          volumes:
          - name: tmp
            emptyDir: {}
          restartPolicy: OnFailure
