#!/bin/bash
set -e

# Enhanced K3s encryption key rotation script
# Includes proper verification and staged rotation

ENCRYPTION_DIR="{{ k3s_map.node.directory.encryption }}"
CONFIG_FILE="$ENCRYPTION_DIR/encryption-config.yaml"
BACKUP_DIR="$ENCRYPTION_DIR/backups"
TIMESTAMP=$(date +%Y%m%d%H%M%S)
LOGFILE="/var/log/k3s-key-rotation-$TIMESTAMP.log"

log() {
  echo "[$(date +%Y-%m-%d\ %H:%M:%S)] $1" | tee -a $LOGFILE
}

log "Starting encryption key rotation process"

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Backup current config
cp "$CONFIG_FILE" "$BACKUP_DIR/encryption-config-$TIMESTAMP.yaml"
log "Backed up current encryption configuration"

# Extract current key for verification
OLD_KEY=$(grep -A 3 "aescbc" "$CONFIG_FILE" | grep "secret" | awk -F': ' '{print $2}')
log "Retrieved current encryption key for verification"

# Generate new encryption key
NEW_KEY=$(head -c 32 /dev/urandom | base64)
log "Generated new encryption key"

# STAGE 1: Add new key as primary, keep old key as secondary
log "STAGE 1: Adding new key while keeping old key as secondary"
cat > "$CONFIG_FILE" << EOF
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: $NEW_KEY
            - name: key2
              secret: $OLD_KEY
      - identity: {}
EOF

# Update permissions
chmod 0600 "$CONFIG_FILE"
log "Updated encryption configuration with new key"

# Restart K3s to apply the new key
log "Restarting K3s to apply new encryption configuration"
systemctl restart k3s.service

# Wait for the API server to be available
log "Waiting for API server to become available..."
TIMEOUT=300
START_TIME=$(date +%s)
while ! kubectl get nodes &>/dev/null; do
  CURRENT_TIME=$(date +%s)
  ELAPSED_TIME=$((CURRENT_TIME - START_TIME))

  if [ $ELAPSED_TIME -ge $TIMEOUT ]; then
    log "ERROR: Timed out waiting for API server to become available"
    exit 1
  fi

  log "API server not yet available. Waiting..."
  sleep 5
done
log "API server is available"

# Re-encrypt all secrets with the new key
log "Re-encrypting all secrets with new key"
NAMESPACES=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}')
for NS in $NAMESPACES; do
  log "Processing namespace: $NS"
  SECRETS=$(kubectl get secrets -n $NS -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
  for SECRET in $SECRETS; do
    # Skip service account tokens as they're managed differently
    if kubectl get secret -n $NS $SECRET -o jsonpath='{.type}' | grep -q "kubernetes.io/service-account-token"; then
      continue
    fi
    log "  Re-encrypting secret: $SECRET"
    kubectl get secret -n $NS $SECRET -o yaml | kubectl apply -f -
  done
done

# STAGE 2: Comprehensive verification before removing old key
log "STAGE 2: Comprehensive verification before removing old key"

# Count total secrets in the cluster
TOTAL_SECRET_COUNT=0
for NS in $NAMESPACES; do
  NS_SECRET_COUNT=$(kubectl get secrets -n $NS --no-headers 2>/dev/null | wc -l)
  TOTAL_SECRET_COUNT=$((TOTAL_SECRET_COUNT + NS_SECRET_COUNT))
done

# Sample a larger set of secrets for verification (at least 20% of all secrets)
VERIFICATION_COUNT=0
VERIFICATION_FAILED=0
VERIFICATION_SAMPLE_SIZE=$(( TOTAL_SECRET_COUNT / 5 ))
VERIFICATION_SAMPLE_SIZE=$(( VERIFICATION_SAMPLE_SIZE < 10 ? 10 : VERIFICATION_SAMPLE_SIZE ))

for NS in $NAMESPACES; do
  # Get secrets from each namespace
  SECRETS=$(kubectl get secrets -n $NS -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

  for SECRET in $SECRETS; do
    # Skip if we've verified enough secrets
    if [ $VERIFICATION_COUNT -ge $VERIFICATION_SAMPLE_SIZE ]; then
      continue
    fi

    # Skip service account tokens
    if kubectl get secret -n $NS $SECRET -o jsonpath='{.type}' | grep -q "kubernetes.io/service-account-token"; then
      continue
    fi

    # Test secret accessibility
    if ! kubectl get secret -n $NS $SECRET -o yaml &>/dev/null; then
      log "  âœ— SECRET $NS/$SECRET is NOT accessible - key rotation failed"
      VERIFICATION_FAILED=1
    else
      VERIFICATION_COUNT=$((VERIFICATION_COUNT+1))
    fi
  done
done

log "Verified $VERIFICATION_COUNT secrets out of approximately $TOTAL_SECRET_COUNT total secrets"

if [ $VERIFICATION_FAILED -eq 1 ] || [ $VERIFICATION_COUNT -eq 0 ]; then
  log "ERROR: Verification failed! Some secrets may not be accessible with new key."
  log "Reverting to previous configuration with both keys to ensure access."

  # Restore configuration with both keys - we keep both keys active for safety
  chmod 0600 "$CONFIG_FILE"
  log "Keeping dual-key configuration for safety. Manual intervention required."

  # We don't remove the old key since verification failed
  exit 1
fi

# STAGE 3: Remove the old key after successful verification
log "STAGE 3: Removing old key from configuration - verification passed"
cat > "$CONFIG_FILE" << EOF
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: $NEW_KEY
      - identity: {}
EOF

# Update permissions
chmod 0600 "$CONFIG_FILE"
log "Updated encryption configuration to remove old key"

# Final restart to apply config with only new key
log "Restarting K3s to apply final configuration"
systemctl restart k3s.service

log "Waiting for API server to become available..."
TIMEOUT=300
START_TIME=$(date +%s)
while ! kubectl get nodes &>/dev/null; do
  CURRENT_TIME=$(date +%s)
  ELAPSED_TIME=$((CURRENT_TIME - START_TIME))

  if [ $ELAPSED_TIME -ge $TIMEOUT ]; then
    log "ERROR: Timed out waiting for API server to become available"
    exit 1
  fi

  log "API server not yet available. Waiting..."
  sleep 5
done

# Final verification step - make sure we can still access a sample of secrets
log "Final verification - checking secret accessibility..."
FINAL_VERIFICATION_FAILED=0

for NS in $NAMESPACES; do
  # Sample a few secrets from each namespace
  SAMPLE_SECRETS=$(kubectl get secrets -n $NS -o name 2>/dev/null | head -3)

  for SECRET in $SAMPLE_SECRETS; do
    if ! kubectl get -n $NS $SECRET -o name &>/dev/null; then
      log "ERROR: Cannot access $NS/$SECRET after final key removal!"
      FINAL_VERIFICATION_FAILED=1
    fi
  done
done

if [ $FINAL_VERIFICATION_FAILED -eq 1 ]; then
  log "CRITICAL ERROR: Some secrets inaccessible after key rotation! Immediate action required."
  log "Consider restoring from backup: $BACKUP_DIR/encryption-config-$TIMESTAMP.yaml"
  exit 1
fi

log "Key rotation completed successfully"
echo "New encryption key: $NEW_KEY"
log "Please update the global_map.k3s.encryption.key in Ansible Vault with this new key"
